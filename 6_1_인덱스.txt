Balanced-Tree(균형 트리)구조로 구현됨
균형을 위한 재조정이란? B-Tree의 각 노드는 일정한 수의 자식 노드를 가질 수 있으며 노드가 가득 차게 되면 노드는 자동으로 분할(중앙값을 기준으로 노드를 나눔)
------------------------------------------------------------

인덱스 종류
클러스터형 인덱스 : PK 또는 PK없이 Unique+NotNull설정된 컬럼
  행 데이터를 자신의 열을 기준으로 정렬함
  테이블 당 하나만 생성 가능  

보조 인덱스 : Unique, 사용자용 인덱스
  별도의 공간을 추가하여 지정한 컬럼만 정렬하여 인덱스를 운영
  컬럼 단위로 여러개의 인덱스 생성 가능
------------------------------------------------------------

인덱스 확인
  SHOW INDEX FROM 테이블명
인덱스 생성
  CREATE UNIQUE INDEX 인덱스명 ON 테이블명(컬럼,,,);
인덱스 제거
  DROP INDEX 인덱스명 ON 테이블명;
------------------------------------------------------------
인덱스가 영향을 미치는 곳 : WHERE, ORDER BY  
SELECT * FROM users WHERE email = 'abc@test.com';
email에 인덱스가 없으면 → 전체 테이블 순차 검색 (Full Table Scan)
email에 인덱스가 있으면 → 인덱스를 통해 빠르게 위치 찾고, 해당 row로 이동
------------------------------------------------------------
인덱스의 장점
 조회 속도 향상
 정렬 성능 향상 (ORDER BY, GROUP BY)
 JOIN 성능 향상
 WHERE 조건에 빠르게 대응 가능

인덱스의 단점
 인덱스도 디스크에 저장되므로 공간 소모
 INSERT, UPDATE, DELETE 시 인덱스도 같이 갱신되므로 성능 저하
 너무 많은 인덱스는 오히려 전체 성능 악화
 잘못된 인덱스 설계는 무용지물
------------------------------------------------------------
**복합 인덱스 
MySQL은 복합 인덱스를 왼쪽부터 순차적으로 사용한다
선두 컬럼을 기준으로만 효율적으로 작동하며, 그 후에 나오는 컬럼들에 대해서는 조건이 연쇄적으로 이어져야만 인덱스를 잘 사용할 수 있습니다. 선두 컬럼이 적절하지 않으면 인덱스가 사용되지 않거나, 비효율적인 풀 테이블 스캔이 발생할 수 있다
   ex) 복합 인덱스 (A, B, C)가 있다면 A에 대한 조건이 먼저 있어야 복합 인덱스가 사용된다
         B나 C에만 조건이 있고 A에 조건이 없다면, 이 복합 인덱스는 사용되지 않는다

------------------------------------------------------------
EXPLAIN을 사용한 쿼리 분석
인덱스를 잘못 사용하거나 쿼리 최적화가 부족한 부분을 찾을 수 있다. 
EXPLAIN의 결과를 통해 인덱스가 잘 사용되고 있는지, 풀 테이블 스캔이 발생하는지 확인가능하다.
ex)
EXPLAIN
SELECT *
FROM starbucks.order_line
ORDER BY order_prod_no; 

EXPLAIN의 주요 컬럼
id :  쿼리의 실행 순서. 여러 개의 테이블을 조인하는 쿼리에서는, 각 테이블이 실행되는 순서를 나타냅니다. id 값이 작을수록 우선순위가 높음.

select_type : 쿼리의 유형. 
  SIMPLE - 단일 테이블만 사용되는 쿼리 
  PRIMARY - 쿼리에서 첫 번째 SELECT 문
  SUBQUERY - 서브쿼리 내의 SELECT 문
ex)
EXPLAIN
SELECT * 
FROM starbucks.order_info  
WHERE order_id < (SELECT id FROM starbucks.customer WHERE name='n1');

-id----select_type---------table------type--ref
  1     PRIMARY	  order_info      ref   const
  2     SUBQUERY	  customer       ALL  

  UNION - UNION으로 결합된 쿼리, 
  

table : 해당 단계에서 사용 테이블 이름.

type : 테이블 접근 방식(조인 방식)을 말한다 
         쿼리 최적화에서 중요한 부분으로, 더 좋은 방식으로 접근하는 것이 성능에 도움이 된다.
  ALL: 풀 테이블 스캔 (성능이 가장 나쁨)
 

-- type : ALL 풀 테이블 스캔 (성능이 가장 나쁨)
EXPLAIN
SELECT *
FROM starbucks.order_line
ORDER BY order_prod_no; 

-- type : index 인덱스를 이용한 접근
EXPLAIN
SELECT *
FROM starbucks.order_line
ORDER BY order_line_no;

-- type : range 인덱스 범위 검색
EXPLAIN
SELECT *
FROM starbucks.order_line
WHERE order_line_no > 1;

-- type : ref 인덱스를 사용해 특정 값으로 검색
EXPLAIN
SELECT *
FROM starbucks.order_line
WHERE order_line_no = 1;

-- type : const 상수값으로 접근 (가장 빠름)
EXPLAIN
SELECT *
FROM starbucks.order_line
WHERE order_line_no = 1 AND order_prod_no='C0001';


possible_keys : 쿼리에서 사용할 수 있는 인덱스들을 보여준다
key : 실제로 사용된 인덱스. 만약 인덱스가 사용되지 않으면 NULL로 표시.
key_len : 실제로 사용된 인덱스의 길이(바이트). 이 값은 인덱스가 몇 개의 컬럼을 사용되는가 알 수 있다.
ref : 어떤 컬럼이 인덱스를 통해 참조되는 컬럼.  ref가 const로 표시되면 상수값을 기준으로 검색하고 있다는 의미.
rows : MySQL이 예상하는 조회할 행의 수. 이 값이 클수록 쿼리 성능이 나빠질 가능성이 높다. 
Extra : 쿼리 실행에 대한 추가적인 정보를 제공
  Using index: 커버링 인덱스를 사용하여 테이블을 읽음
  Using where: WHERE 조건이 적용됨
  Using temporary: 임시 테이블을 사용하여 결과를 처리하는 경우
  Using filesort: 정렬 작업을 위해 파일 정렬을 사용하는 경우